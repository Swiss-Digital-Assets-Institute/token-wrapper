/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace IHederaTokenService {
  export type KeyValueStruct = {
    inheritAccountKey: boolean;
    contractId: string;
    ed25519: BytesLike;
    ECDSA_secp256k1: BytesLike;
    delegatableContractId: string;
  };

  export type KeyValueStructOutput = [
    boolean,
    string,
    string,
    string,
    string
  ] & {
    inheritAccountKey: boolean;
    contractId: string;
    ed25519: string;
    ECDSA_secp256k1: string;
    delegatableContractId: string;
  };

  export type TokenKeyStruct = {
    keyType: BigNumberish;
    key: IHederaTokenService.KeyValueStruct;
  };

  export type TokenKeyStructOutput = [
    BigNumber,
    IHederaTokenService.KeyValueStructOutput
  ] & { keyType: BigNumber; key: IHederaTokenService.KeyValueStructOutput };

  export type ExpiryStruct = {
    second: BigNumberish;
    autoRenewAccount: string;
    autoRenewPeriod: BigNumberish;
  };

  export type ExpiryStructOutput = [BigNumber, string, BigNumber] & {
    second: BigNumber;
    autoRenewAccount: string;
    autoRenewPeriod: BigNumber;
  };

  export type HederaTokenStruct = {
    name: string;
    symbol: string;
    treasury: string;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: BigNumberish;
    freezeDefault: boolean;
    tokenKeys: IHederaTokenService.TokenKeyStruct[];
    expiry: IHederaTokenService.ExpiryStruct;
  };

  export type HederaTokenStructOutput = [
    string,
    string,
    string,
    string,
    boolean,
    BigNumber,
    boolean,
    IHederaTokenService.TokenKeyStructOutput[],
    IHederaTokenService.ExpiryStructOutput
  ] & {
    name: string;
    symbol: string;
    treasury: string;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: BigNumber;
    freezeDefault: boolean;
    tokenKeys: IHederaTokenService.TokenKeyStructOutput[];
    expiry: IHederaTokenService.ExpiryStructOutput;
  };

  export type FixedFeeStruct = {
    amount: BigNumberish;
    tokenId: string;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: string;
  };

  export type FixedFeeStructOutput = [
    BigNumber,
    string,
    boolean,
    boolean,
    string
  ] & {
    amount: BigNumber;
    tokenId: string;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: string;
  };

  export type FractionalFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    minimumAmount: BigNumberish;
    maximumAmount: BigNumberish;
    netOfTransfers: boolean;
    feeCollector: string;
  };

  export type FractionalFeeStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    string
  ] & {
    numerator: BigNumber;
    denominator: BigNumber;
    minimumAmount: BigNumber;
    maximumAmount: BigNumber;
    netOfTransfers: boolean;
    feeCollector: string;
  };

  export type RoyaltyFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    amount: BigNumberish;
    tokenId: string;
    useHbarsForPayment: boolean;
    feeCollector: string;
  };

  export type RoyaltyFeeStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    boolean,
    string
  ] & {
    numerator: BigNumber;
    denominator: BigNumber;
    amount: BigNumber;
    tokenId: string;
    useHbarsForPayment: boolean;
    feeCollector: string;
  };

  export type AccountAmountStruct = {
    accountID: string;
    amount: BigNumberish;
    isApproval: boolean;
  };

  export type AccountAmountStructOutput = [string, BigNumber, boolean] & {
    accountID: string;
    amount: BigNumber;
    isApproval: boolean;
  };

  export type TransferListStruct = {
    transfers: IHederaTokenService.AccountAmountStruct[];
  };

  export type TransferListStructOutput = [
    IHederaTokenService.AccountAmountStructOutput[]
  ] & { transfers: IHederaTokenService.AccountAmountStructOutput[] };

  export type NftTransferStruct = {
    senderAccountID: string;
    receiverAccountID: string;
    serialNumber: BigNumberish;
    isApproval: boolean;
  };

  export type NftTransferStructOutput = [string, string, BigNumber, boolean] & {
    senderAccountID: string;
    receiverAccountID: string;
    serialNumber: BigNumber;
    isApproval: boolean;
  };

  export type TokenTransferListStruct = {
    token: string;
    transfers: IHederaTokenService.AccountAmountStruct[];
    nftTransfers: IHederaTokenService.NftTransferStruct[];
  };

  export type TokenTransferListStructOutput = [
    string,
    IHederaTokenService.AccountAmountStructOutput[],
    IHederaTokenService.NftTransferStructOutput[]
  ] & {
    token: string;
    transfers: IHederaTokenService.AccountAmountStructOutput[];
    nftTransfers: IHederaTokenService.NftTransferStructOutput[];
  };

  export type TokenInfoStruct = {
    token: IHederaTokenService.HederaTokenStruct;
    totalSupply: BigNumberish;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStruct[];
    fractionalFees: IHederaTokenService.FractionalFeeStruct[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[];
    ledgerId: string;
  };

  export type TokenInfoStructOutput = [
    IHederaTokenService.HederaTokenStructOutput,
    BigNumber,
    boolean,
    boolean,
    boolean,
    IHederaTokenService.FixedFeeStructOutput[],
    IHederaTokenService.FractionalFeeStructOutput[],
    IHederaTokenService.RoyaltyFeeStructOutput[],
    string
  ] & {
    token: IHederaTokenService.HederaTokenStructOutput;
    totalSupply: BigNumber;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStructOutput[];
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
    ledgerId: string;
  };

  export type FungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    decimals: BigNumberish;
  };

  export type FungibleTokenInfoStructOutput = [
    IHederaTokenService.TokenInfoStructOutput,
    number
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    decimals: number;
  };

  export type NonFungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    serialNumber: BigNumberish;
    ownerId: string;
    creationTime: BigNumberish;
    metadata: BytesLike;
    spenderId: string;
  };

  export type NonFungibleTokenInfoStructOutput = [
    IHederaTokenService.TokenInfoStructOutput,
    BigNumber,
    string,
    BigNumber,
    string,
    string
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    serialNumber: BigNumber;
    ownerId: string;
    creationTime: BigNumber;
    metadata: string;
    spenderId: string;
  };
}

export interface IHederaTokenServiceInterface extends utils.Interface {
  functions: {
    "allowance(address,address,address)": FunctionFragment;
    "approve(address,address,uint256)": FunctionFragment;
    "approveNFT(address,address,uint256)": FunctionFragment;
    "associateToken(address,address)": FunctionFragment;
    "associateTokens(address,address[])": FunctionFragment;
    "burnToken(address,int64,int64[])": FunctionFragment;
    "createFungibleToken((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(int64,address,int64)),int64,int32)": FunctionFragment;
    "createFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(int64,address,int64)),int64,int32,(int64,address,bool,bool,address)[],(int64,int64,int64,int64,bool,address)[])": FunctionFragment;
    "createNonFungibleToken((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(int64,address,int64)))": FunctionFragment;
    "createNonFungibleTokenWithCustomFees((string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(int64,address,int64)),(int64,address,bool,bool,address)[],(int64,int64,int64,address,bool,address)[])": FunctionFragment;
    "cryptoTransfer(((address,int64,bool)[]),(address,(address,int64,bool)[],(address,address,int64,bool)[])[])": FunctionFragment;
    "deleteToken(address)": FunctionFragment;
    "dissociateToken(address,address)": FunctionFragment;
    "dissociateTokens(address,address[])": FunctionFragment;
    "freezeToken(address,address)": FunctionFragment;
    "getApproved(address,uint256)": FunctionFragment;
    "getFungibleTokenInfo(address)": FunctionFragment;
    "getNonFungibleTokenInfo(address,int64)": FunctionFragment;
    "getTokenCustomFees(address)": FunctionFragment;
    "getTokenDefaultFreezeStatus(address)": FunctionFragment;
    "getTokenDefaultKycStatus(address)": FunctionFragment;
    "getTokenExpiryInfo(address)": FunctionFragment;
    "getTokenInfo(address)": FunctionFragment;
    "getTokenKey(address,uint256)": FunctionFragment;
    "getTokenType(address)": FunctionFragment;
    "grantTokenKyc(address,address)": FunctionFragment;
    "isApprovedForAll(address,address,address)": FunctionFragment;
    "isFrozen(address,address)": FunctionFragment;
    "isKyc(address,address)": FunctionFragment;
    "isToken(address)": FunctionFragment;
    "mintToken(address,int64,bytes[])": FunctionFragment;
    "pauseToken(address)": FunctionFragment;
    "redirectForToken(address,bytes)": FunctionFragment;
    "revokeTokenKyc(address,address)": FunctionFragment;
    "setApprovalForAll(address,address,bool)": FunctionFragment;
    "transferFrom(address,address,address,uint256)": FunctionFragment;
    "transferFromNFT(address,address,address,uint256)": FunctionFragment;
    "transferNFT(address,address,address,int64)": FunctionFragment;
    "transferNFTs(address,address[],address[],int64[])": FunctionFragment;
    "transferToken(address,address,address,int64)": FunctionFragment;
    "transferTokens(address,address[],int64[])": FunctionFragment;
    "unfreezeToken(address,address)": FunctionFragment;
    "unpauseToken(address)": FunctionFragment;
    "updateTokenExpiryInfo(address,(int64,address,int64))": FunctionFragment;
    "updateTokenInfo(address,(string,string,address,string,bool,int64,bool,(uint256,(bool,address,bytes,bytes,address))[],(int64,address,int64)))": FunctionFragment;
    "updateTokenKeys(address,(uint256,(bool,address,bytes,bytes,address))[])": FunctionFragment;
    "wipeTokenAccount(address,address,int64)": FunctionFragment;
    "wipeTokenAccountNFT(address,address,int64[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "allowance"
      | "approve"
      | "approveNFT"
      | "associateToken"
      | "associateTokens"
      | "burnToken"
      | "createFungibleToken"
      | "createFungibleTokenWithCustomFees"
      | "createNonFungibleToken"
      | "createNonFungibleTokenWithCustomFees"
      | "cryptoTransfer"
      | "deleteToken"
      | "dissociateToken"
      | "dissociateTokens"
      | "freezeToken"
      | "getApproved"
      | "getFungibleTokenInfo"
      | "getNonFungibleTokenInfo"
      | "getTokenCustomFees"
      | "getTokenDefaultFreezeStatus"
      | "getTokenDefaultKycStatus"
      | "getTokenExpiryInfo"
      | "getTokenInfo"
      | "getTokenKey"
      | "getTokenType"
      | "grantTokenKyc"
      | "isApprovedForAll"
      | "isFrozen"
      | "isKyc"
      | "isToken"
      | "mintToken"
      | "pauseToken"
      | "redirectForToken"
      | "revokeTokenKyc"
      | "setApprovalForAll"
      | "transferFrom"
      | "transferFromNFT"
      | "transferNFT"
      | "transferNFTs"
      | "transferToken"
      | "transferTokens"
      | "unfreezeToken"
      | "unpauseToken"
      | "updateTokenExpiryInfo"
      | "updateTokenInfo"
      | "updateTokenKeys"
      | "wipeTokenAccount"
      | "wipeTokenAccountNFT"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveNFT",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "associateToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "associateTokens",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken",
    values: [string, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      BigNumberish,
      BigNumberish,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cryptoTransfer",
    values: [
      IHederaTokenService.TransferListStruct,
      IHederaTokenService.TokenTransferListStruct[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "deleteToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "dissociateToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateTokens",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFungibleTokenInfo",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonFungibleTokenInfo",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenCustomFees",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultFreezeStatus",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultKycStatus",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenExpiryInfo",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenInfo",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenKey",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenType",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isFrozen",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isKyc",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "isToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "mintToken",
    values: [string, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "pauseToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "redirectForToken",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromNFT",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFT",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFTs",
    values: [string, string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokens",
    values: [string, string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenExpiryInfo",
    values: [string, IHederaTokenService.ExpiryStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo",
    values: [string, IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys",
    values: [string, IHederaTokenService.TokenKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccountNFT",
    values: [string, string, BigNumberish[]]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approveNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "associateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cryptoTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultFreezeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultKycStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isKyc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pauseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redirectForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccountNFT",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IHederaTokenService extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IHederaTokenServiceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    approveNFT(
      token: string,
      approved: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    associateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    associateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    deleteToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    dissociateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    dissociateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getApproved(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getFungibleTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getNonFungibleTokenInfo(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenCustomFees(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenDefaultFreezeStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenDefaultKycStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenExpiryInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenKey(
      token: string,
      keyType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getTokenType(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      token: string,
      owner: string,
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    isFrozen(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    isKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    isToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    pauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      token: string,
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferFromNFT(
      token: string,
      from: string,
      to: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferNFT(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferNFTs(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferTokens(
      token: string,
      accountId: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unpauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateTokenExpiryInfo(
      token: string,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateTokenInfo(
      token: string,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateTokenKeys(
      token: string,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    wipeTokenAccountNFT(
      token: string,
      account: string,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  allowance(
    token: string,
    owner: string,
    spender: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  approve(
    token: string,
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  approveNFT(
    token: string,
    approved: string,
    serialNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  associateToken(
    account: string,
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  associateTokens(
    account: string,
    tokens: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  burnToken(
    token: string,
    amount: BigNumberish,
    serialNumbers: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  createFungibleToken(
    token: IHederaTokenService.HederaTokenStruct,
    initialTotalSupply: BigNumberish,
    decimals: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  createFungibleTokenWithCustomFees(
    token: IHederaTokenService.HederaTokenStruct,
    initialTotalSupply: BigNumberish,
    decimals: BigNumberish,
    fixedFees: IHederaTokenService.FixedFeeStruct[],
    fractionalFees: IHederaTokenService.FractionalFeeStruct[],
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  createNonFungibleToken(
    token: IHederaTokenService.HederaTokenStruct,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  createNonFungibleTokenWithCustomFees(
    token: IHederaTokenService.HederaTokenStruct,
    fixedFees: IHederaTokenService.FixedFeeStruct[],
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  cryptoTransfer(
    transferList: IHederaTokenService.TransferListStruct,
    tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  deleteToken(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  dissociateToken(
    account: string,
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  dissociateTokens(
    account: string,
    tokens: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  freezeToken(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getApproved(
    token: string,
    serialNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getFungibleTokenInfo(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getNonFungibleTokenInfo(
    token: string,
    serialNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenCustomFees(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenDefaultFreezeStatus(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenDefaultKycStatus(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenExpiryInfo(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenInfo(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenKey(
    token: string,
    keyType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getTokenType(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  grantTokenKyc(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    token: string,
    owner: string,
    operator: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  isFrozen(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  isKyc(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  isToken(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  mintToken(
    token: string,
    amount: BigNumberish,
    metadata: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  pauseToken(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  redirectForToken(
    token: string,
    encodedFunctionSelector: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  revokeTokenKyc(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    token: string,
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferFrom(
    token: string,
    from: string,
    to: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferFromNFT(
    token: string,
    from: string,
    to: string,
    serialNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferNFT(
    token: string,
    sender: string,
    recipient: string,
    serialNumber: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferNFTs(
    token: string,
    sender: string[],
    receiver: string[],
    serialNumber: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferToken(
    token: string,
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferTokens(
    token: string,
    accountId: string[],
    amount: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unfreezeToken(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unpauseToken(
    token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateTokenExpiryInfo(
    token: string,
    expiryInfo: IHederaTokenService.ExpiryStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateTokenInfo(
    token: string,
    tokenInfo: IHederaTokenService.HederaTokenStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateTokenKeys(
    token: string,
    keys: IHederaTokenService.TokenKeyStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  wipeTokenAccount(
    token: string,
    account: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  wipeTokenAccountNFT(
    token: string,
    account: string,
    serialNumbers: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { responseCode: BigNumber; allowance: BigNumber }
    >;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approveNFT(
      token: string,
      approved: string,
      serialNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    associateToken(
      account: string,
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    associateTokens(
      account: string,
      tokens: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        responseCode: BigNumber;
        newTotalSupply: BigNumber;
      }
    >;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; tokenAddress: string }
    >;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deleteToken(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    dissociateToken(
      account: string,
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    dissociateTokens(
      account: string,
      tokens: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    freezeToken(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproved(
      token: string,
      serialNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; approved: string }
    >;

    getFungibleTokenInfo(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.FungibleTokenInfoStructOutput] & {
        responseCode: BigNumber;
        fungibleTokenInfo: IHederaTokenService.FungibleTokenInfoStructOutput;
      }
    >;

    getNonFungibleTokenInfo(
      token: string,
      serialNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.NonFungibleTokenInfoStructOutput] & {
        responseCode: BigNumber;
        nonFungibleTokenInfo: IHederaTokenService.NonFungibleTokenInfoStructOutput;
      }
    >;

    getTokenCustomFees(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ] & {
        responseCode: BigNumber;
        fixedFees: IHederaTokenService.FixedFeeStructOutput[];
        fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
        royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
      }
    >;

    getTokenDefaultFreezeStatus(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        responseCode: BigNumber;
        defaultFreezeStatus: boolean;
      }
    >;

    getTokenDefaultKycStatus(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & {
        responseCode: BigNumber;
        defaultKycStatus: boolean;
      }
    >;

    getTokenExpiryInfo(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.ExpiryStructOutput] & {
        responseCode: BigNumber;
        expiry: IHederaTokenService.ExpiryStructOutput;
      }
    >;

    getTokenInfo(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.TokenInfoStructOutput] & {
        responseCode: BigNumber;
        tokenInfo: IHederaTokenService.TokenInfoStructOutput;
      }
    >;

    getTokenKey(
      token: string,
      keyType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, IHederaTokenService.KeyValueStructOutput] & {
        responseCode: BigNumber;
        key: IHederaTokenService.KeyValueStructOutput;
      }
    >;

    getTokenType(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number] & { responseCode: BigNumber; tokenType: number }
    >;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isApprovedForAll(
      token: string,
      owner: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; approved: boolean }
    >;

    isFrozen(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; frozen: boolean }
    >;

    isKyc(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; kycGranted: boolean }
    >;

    isToken(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { responseCode: BigNumber; isToken: boolean }
    >;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber[]] & {
        responseCode: BigNumber;
        newTotalSupply: BigNumber;
        serialNumbers: BigNumber[];
      }
    >;

    pauseToken(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string] & { responseCode: BigNumber; response: string }
    >;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setApprovalForAll(
      token: string,
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferFromNFT(
      token: string,
      from: string,
      to: string,
      serialNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferNFT(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferNFTs(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferTokens(
      token: string,
      accountId: string[],
      amount: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpauseToken(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    updateTokenExpiryInfo(
      token: string,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: string,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: string,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wipeTokenAccountNFT(
      token: string,
      account: string,
      serialNumbers: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    approveNFT(
      token: string,
      approved: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    associateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    associateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    deleteToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    dissociateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    dissociateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getApproved(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getFungibleTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getNonFungibleTokenInfo(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenCustomFees(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenDefaultFreezeStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenDefaultKycStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenExpiryInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenKey(
      token: string,
      keyType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getTokenType(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    isApprovedForAll(
      token: string,
      owner: string,
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    isFrozen(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    isKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    isToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    pauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setApprovalForAll(
      token: string,
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferFromNFT(
      token: string,
      from: string,
      to: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferNFT(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferNFTs(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferTokens(
      token: string,
      accountId: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unpauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateTokenExpiryInfo(
      token: string,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateTokenInfo(
      token: string,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateTokenKeys(
      token: string,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    wipeTokenAccountNFT(
      token: string,
      account: string,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allowance(
      token: string,
      owner: string,
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    approve(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    approveNFT(
      token: string,
      approved: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    associateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    associateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    burnToken(
      token: string,
      amount: BigNumberish,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createNonFungibleToken(
      token: IHederaTokenService.HederaTokenStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createNonFungibleTokenWithCustomFees(
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    cryptoTransfer(
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    deleteToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    dissociateToken(
      account: string,
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    dissociateTokens(
      account: string,
      tokens: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    freezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getApproved(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getFungibleTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getNonFungibleTokenInfo(
      token: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenCustomFees(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenDefaultFreezeStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenDefaultKycStatus(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenExpiryInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenInfo(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenKey(
      token: string,
      keyType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getTokenType(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    grantTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      token: string,
      owner: string,
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isFrozen(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    isToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    mintToken(
      token: string,
      amount: BigNumberish,
      metadata: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    pauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    redirectForToken(
      token: string,
      encodedFunctionSelector: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    revokeTokenKyc(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      token: string,
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferFrom(
      token: string,
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferFromNFT(
      token: string,
      from: string,
      to: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferNFT(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferNFTs(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferToken(
      token: string,
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferTokens(
      token: string,
      accountId: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unfreezeToken(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unpauseToken(
      token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateTokenExpiryInfo(
      token: string,
      expiryInfo: IHederaTokenService.ExpiryStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateTokenInfo(
      token: string,
      tokenInfo: IHederaTokenService.HederaTokenStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateTokenKeys(
      token: string,
      keys: IHederaTokenService.TokenKeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    wipeTokenAccount(
      token: string,
      account: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    wipeTokenAccountNFT(
      token: string,
      account: string,
      serialNumbers: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
